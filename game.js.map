{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./public/assets/blood-splat-icon.png","webpack:///./public/assets/foods.png","webpack:///./public/assets/grass.png","webpack:///./public/assets/red_X.png","webpack:///./public/assets/splatsound.wav","webpack:///./src/bugs.ts","webpack:///./src/images.js","webpack:///./src/index.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAe,oFAAuB,yCAAyC,E;;;;;;;;;;;;ACA/E;AAAe,oFAAuB,yCAAyC,E;;;;;;;;;;;;ACA/E;AAAe,oFAAuB,yCAAyC,E;;;;;;;;;;;;ACA/E;AAAe,oFAAuB,yCAAyC,E;;;;;;;;;;;;ACA/E;AAAe,oFAAuB,yCAAyC,E;;;;;;;;;;;;ACA/E;AAAA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACpBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C;AACN;AACY;AACZ;AACQ;;AAE1C;AACA;AACA;AACA;AACA,wBAAwB,8DAAU;AACzC,YAAY,yDAAO;AACnB,iBAAiB,yDAAa;AAC9B,iBAAiB,oEAAQ;AACzB,WAAW,yDAAO;AAClB,iBAAiB,yDAAa;;AAE9B;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAqD;AACiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6CAAK;AAC3B;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAAQ;AACvB;AACA;AACA,eAAe,4CAAM;AACrB;AACA;AACA,eAAe,+CAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAK;AACrB;AACA;AACA;AACA,0BAA0B,kDAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4CAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA","file":"game.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","export default __webpack_public_path__ + \"21d38cf216a7e28988614a53157fd5af.png\";","export default __webpack_public_path__ + \"5794f371b03fdacbf839da9aee0baddd.png\";","export default __webpack_public_path__ + \"2055df7e8ccfbe56d72721d3ca1e7e99.png\";","export default __webpack_public_path__ + \"4c4bfe66508080144ef97ca92d71b056.png\";","export default __webpack_public_path__ + \"daddf030ec596d9ab017e6df49a378c2.wav\";","export var blackBug = Object.freeze({\n    color: \"rgba(0, 0, 0)\",\n    speed1: 0.15,\n    speed2: 0.2,\n    score: 5,\n    probability: 0.3,\n});\nexport var redBug = Object.freeze({\n    color: \"rgba(255, 0, 0)\",\n    speed1: 0.075,\n    speed2: 0.1,\n    score: 3,\n    probability: 0.3,\n});\nexport var orangeBug = Object.freeze({\n    color: \"rgba(255, 102, 0)\",\n    speed1: 0.06,\n    speed2: 0.08,\n    score: 1,\n    probability: 0.4,\n});\n","import backgroundImg from \"@/assets/grass.png\";\nimport foodImg from \"@/assets/foods.png\";\nimport splatImg from \"@/assets/blood-splat-icon.png\";\nimport redXImg from \"@/assets/red_X.png\";\nimport splatSound from \"@/assets/splatsound.wav\";\n\nexport const foods = new Image();\nexport const background = new Image();\nexport const bloodSplat = new Image();\nexport const redX = new Image();\nexport const splat = new Audio(splatSound);\nfoods.src = foodImg;\nbackground.src = backgroundImg;\nbloodSplat.src = splatImg;\nredX.src = redXImg;\nbackground.src = backgroundImg;\n\n// // var backgroundMusic = new Audio(\"Spring_In_My_Step_-_Silent_Partner.wav\");\n","import { orangeBug, blackBug, redBug } from \"./bugs\";\nimport { redX, background, splat, bloodSplat, foods } from \"./images\";\nvar foodArray = [];\nvar bugArray = [];\nvar numOfFood = 10;\nvar scoreBoardHeight = 40;\nvar timeLeft = 60;\nvar score = 0;\nvar requestID;\nvar spawnID;\nvar paused = false;\nvar gameEnded = false;\nvar clickX;\nvar clickY;\nvar pauseDelay = 100;\n// var backgroundMusic = new Audio(\"Spring_In_My_Step_-_Silent_Partner.wav\");\nvar level;\nvar canvas = document.getElementById(\"gameBoard\");\n// Known Issues:\n//1. change of lineWidth changes the width of shape of bugs as well.\n//2. Gameover function not implemented. RESOLVED\n//3. Pausing the game doesn't stop the bug spawning loop.   RESOLVED\n//4. speed differene from level not implemented.   RESOLVED\n//5. Bugs wont fade out when killed RESOLVED\nwindow.addEventListener(\"mousedown\", doMouseDown, false);\nwindow.addEventListener(\"load\", init);\nfunction gameOver() {\n    var ctx = canvas.getContext(\"2d\");\n    gameEnded = true;\n    paused = true;\n    clearTimeout(spawnID);\n    cancelAnimationFrame(requestID);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = \"red\";\n    ctx.strokeStyle = \"black\";\n    ctx.font = \"bold 15px Arial\";\n    ctx.fillText(\"GameOver\", 160, 300);\n    ctx.fillText(\"Your Score is: \" + score, 145, 320);\n    ctx.strokeRect(100, 350, 50, 30);\n    ctx.strokeRect(250, 350, 50, 30);\n    ctx.fillStyle = \"black\";\n    ctx.fillText(\"Replay\", 100, 370);\n    ctx.fillText(\"Exit\", 260, 370);\n    var highScore = Number(localStorage.getItem(\"highscore\")) || 0;\n    localStorage.setItem(\"highscore\", Math.max(highScore, score).toString());\n}\nfunction doMouseDown(event) {\n    clickX = event.pageX - document.getElementById(\"gameBoard\").offsetLeft;\n    clickY = event.pageY - document.getElementById(\"gameBoard\").offsetTop;\n    // Controls for game screen\n    if (gameEnded == false) {\n        //console.log(clickX + \" \" + clickY + paused);\n        if (215 > clickX &&\n            185 < clickX &&\n            scoreBoardHeight / 2 + 15 > clickY &&\n            clickY > scoreBoardHeight / 2 - 15) {\n            paused = !paused;\n            var ctx = canvas.getContext(\"2d\");\n            drawScoreBoard(ctx);\n            //Pause & Unpause the spawning loop.\n            switchStateSpawningLoop();\n            if (paused) {\n                cancelAnimationFrame(requestID);\n            }\n            else {\n                requestID = requestAnimationFrame(mainLoop);\n            }\n        }\n        // Controls for game over screen.\n    }\n    else {\n        //Clicking Replay Button.\n        if (clickX > 100 && clickX < 150 && clickY > 350 && clickY < 380) {\n            location.reload();\n            //Clicking Exit Button.\n        }\n        else if (clickX > 250 && clickX < 300 && clickY > 350 && clickY < 380) {\n            window.location.href = \"start.html\";\n        }\n    }\n}\nexport default function init() {\n    console.log(\"object\");\n    // backgroundMusic.play();\n    var canvas = document.getElementById(\"gameBoard\");\n    var ctx = canvas.getContext(\"2d\");\n    for (var i = 0; i < numOfFood; i++) {\n        foodArray.push(makeNewFood());\n    }\n    level = window.location.href.substr(window.location.href.lastIndexOf(\"=\") + 1, 1);\n    bugDrawingLoop();\n    requestID = requestAnimationFrame(mainLoop);\n}\nfunction switchStateSpawningLoop() {\n    if (paused) {\n        clearTimeout(spawnID);\n    }\n    else {\n        bugDrawingLoop();\n    }\n}\nfunction drawScoreBoard(ctx) {\n    ctx.clearRect(0, 0, 400, scoreBoardHeight);\n    ctx.save();\n    ctx.strokeStyle = \"black\";\n    ctx.fillStyle = \"black\";\n    ctx.beginPath();\n    ctx.moveTo(0, scoreBoardHeight);\n    ctx.lineTo(400, scoreBoardHeight);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.font = \"bold 15px Arial\";\n    ctx.fillText(\"Time Left: \" + Math.round(timeLeft * 10) / 10 + \" sec\", 10, scoreBoardHeight / 2 + 5);\n    ctx.fillText(\"Score: \" + score + \" Points\", 280, scoreBoardHeight / 2 + 5);\n    ctx.strokeStyle = \"black\";\n    ctx.strokeRect(185, scoreBoardHeight / 2 - 15, 30, 30);\n    ctx.restore();\n    if (paused) {\n        console.log(\"here\");\n        ctx.save();\n        ctx.strokeStyle = \"black\";\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.moveTo(189, scoreBoardHeight / 2 - 11);\n        ctx.lineTo(211, scoreBoardHeight / 2);\n        ctx.lineTo(189, scoreBoardHeight / 2 + 11);\n        ctx.lineTo(189, scoreBoardHeight / 2 - 11);\n        ctx.closePath();\n        ctx.stroke();\n        ctx.fill();\n        ctx.restore();\n    }\n    else {\n        console.log(\"alsohere\");\n        ctx.save();\n        ctx.strokeStyle = \"black\";\n        ctx.lineWidth = 6;\n        ctx.beginPath();\n        ctx.moveTo(193, scoreBoardHeight / 2 - 11);\n        ctx.lineTo(193, scoreBoardHeight / 2 + 11);\n        ctx.moveTo(207, scoreBoardHeight / 2 - 11);\n        ctx.lineTo(207, scoreBoardHeight / 2 + 11);\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n}\nfunction mainLoop() {\n    var ctx = canvas.getContext(\"2d\");\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.drawImage(background, 0, 40);\n    if (foodArray.length == 0) {\n        gameOver();\n        return;\n    }\n    var bugsToRemove = [];\n    for (var i = 0; i < foodArray.length; i++) {\n        foodArray[i].draw(ctx);\n        foodArray[i].update(1000 / 60);\n    }\n    for (var i = 0; i < bugArray.length; i++) {\n        bugArray[i].draw(ctx);\n        if (!bugArray[i].update(1000 / 60)) {\n            bugsToRemove.push(i);\n        }\n    }\n    //resets the click point value.\n    clickX = 0;\n    clickY = 0;\n    for (var i = bugsToRemove.length - 1; i >= 0; i--) {\n        bugArray.splice(bugsToRemove[i], 1);\n    }\n    timeLeft -= 1 / 60;\n    if (timeLeft < 0) {\n        timeLeft = 0;\n        gameOver();\n        return;\n    }\n    drawScoreBoard(ctx);\n    requestID = requestAnimationFrame(mainLoop);\n}\nfunction bugDrawingLoop() {\n    var rand = Math.random() * 2000 + 1000; //1-3 seconds\n    spawnID = setTimeout(function () {\n        bugArray.push(makeNewBug());\n        bugDrawingLoop();\n    }, rand);\n}\nfunction makeNewFood() {\n    var valid = false;\n    var pictureX = 5 + Math.floor(Math.random() * 5) * 25;\n    var pictureY = 10 + Math.floor(Math.random() * 2) * 20;\n    //making sure food is not too close to each other.\n    while (valid == false) {\n        valid = true;\n        var x = Math.random() * 360 + 20;\n        var y = Math.random() * 500 + 100 + scoreBoardHeight;\n        for (var i = 0; i < foodArray.length; i++) {\n            if (x + 50 > foodArray[i].x &&\n                foodArray[i].x > x - 50 &&\n                y + 50 > foodArray[i].y &&\n                foodArray[i].y > y - 50) {\n                valid = false;\n            }\n        }\n    }\n    //console.log(\"x: \" + x + \"y: \" + y);\n    //console.log(pictureX);\n    function draw(ctx) {\n        var food = document.getElementById(\"food\");\n        ctx.drawImage(foods, pictureX, pictureY, 20, 20, x, y, 20, 20);\n    }\n    function update(elapsed) {\n        return;\n    }\n    return { draw: draw, update: update, x: x, y: y };\n}\nfunction makeNewBug() {\n    var flag = 0;\n    var type;\n    var rand = Math.random();\n    if (rand < 0.3) {\n        type = blackBug;\n    }\n    else if (rand < 0.6) {\n        type = redBug;\n    }\n    else {\n        type = orangeBug;\n    }\n    //info object.\n    var info = {\n        x: 10 + Math.random() * 380,\n        y: 30 + scoreBoardHeight,\n        type: type,\n        transparency: 1,\n        target: undefined,\n    };\n    function findTargetFood() {\n        var distance = Math.pow(400, 2) + Math.pow(600, 2);\n        var index;\n        if (foodArray.length == 0) {\n            gameOver();\n            return;\n        }\n        else {\n            //find which food to run for.\n            for (var i = 0; i < foodArray.length; i++) {\n                var newdis = Math.pow(foodArray[i].x - info.x, 2) +\n                    Math.pow(foodArray[i].y - info.y, 2);\n                if (newdis < distance) {\n                    distance = newdis;\n                    index = i;\n                }\n            }\n            var target = {\n                x: foodArray[index].x,\n                y: foodArray[index].y,\n                angle: findAngle(info.x, info.y, foodArray[index].x, foodArray[index].y),\n                index: index,\n            };\n            return target;\n        }\n    }\n    info.target = findTargetFood();\n    function parseFillStyle() {\n        return info.type.color + info.transparency + \")\";\n    }\n    function draw(ctx) {\n        if (info.transparency < 1) {\n            if (flag == 0) {\n                splat.play();\n                flag = 1;\n            }\n            ctx.save();\n            ctx.drawImage(bloodSplat, info.x - 15, info.y - 25);\n            ctx.restore();\n        }\n        var xhead = info.x + 5 * Math.cos(info.target.angle);\n        var yhead = info.y + 5 * Math.sin(info.target.angle);\n        var xtail = info.x - 15 * Math.cos(info.target.angle);\n        var ytail = info.y - 15 * Math.sin(info.target.angle);\n        ctx.save();\n        ctx.beginPath();\n        ctx.arc(xhead, yhead, 5, 0, 2 * Math.PI);\n        ctx.closePath();\n        //console.log(parseFillStyle());\n        ctx.fillStyle = parseFillStyle();\n        ctx.fill();\n        ctx.strokeStyle = \"black\";\n        ctx.stroke();\n        ctx.restore();\n        //console.log(xhead + \" \" + yhead + \" \" + xtail + \" \" + ytail);\n        ctx.save(); // save state\n        ctx.beginPath();\n        ctx.translate(xtail, ytail);\n        ctx.rotate(info.target.angle);\n        ctx.scale(15, 5);\n        ctx.arc(0, 0, 1, 0, 2 * Math.PI, false);\n        ctx.closePath();\n        ctx.fillStyle = parseFillStyle();\n        ctx.fill();\n        ctx.restore(); // restore to original state\n        ctx.save();\n        ctx.strokeStyle = \"black\";\n        ctx.stroke();\n        ctx.restore();\n        if (info.transparency < 1) {\n            ctx.save();\n            ctx.globalAlpha = info.transparency;\n            ctx.drawImage(redX, info.x - 15, info.y - 15);\n            ctx.restore();\n        }\n    }\n    function evaluate() {\n        return (info.x > info.target.x - 10 &&\n            info.x < info.target.x + 10 &&\n            info.y > info.target.y - 10 &&\n            info.y < info.target.y + 10);\n    }\n    //return true or false, indicating whether the bug is killed.\n    function update(elapsed) {\n        // If the bug is already fading\n        if (info.transparency < 1) {\n            info.transparency -= 1 / 120;\n            return info.transparency >= 0;\n        }\n        else {\n            var speed;\n            if (level == 1) {\n                speed = info.type.speed1;\n            }\n            else {\n                speed = info.type.speed2;\n            }\n            var distance = speed * elapsed;\n            // If bug is clicked.\n            if (clickX > info.x - 30 &&\n                clickX < info.x + 30 &&\n                clickY > info.y - 30 &&\n                clickY < info.y + 30) {\n                info.transparency -= 1 / 120;\n                score += info.type.score;\n                return true;\n            }\n            info.target = findTargetFood();\n            info.x += distance * Math.cos(info.target.angle);\n            info.y += distance * Math.sin(info.target.angle);\n            //if we are touching the food.\n            if (evaluate()) {\n                foodArray.splice(info.target.index, 1);\n            }\n            return true;\n        }\n    }\n    return { draw: draw, update: update, info: info };\n}\nfunction findAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1);\n}\n"],"sourceRoot":""}